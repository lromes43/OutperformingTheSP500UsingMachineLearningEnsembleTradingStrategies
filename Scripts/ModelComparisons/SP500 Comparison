---
title: "Untitled"
format: html
---

We own a mini hedge fund consisting of $100,000 in assets. Invest $100,000 across 1/5/30 days so $33,333.33 each. Top 10 stocks each.


```{python}
import pandas as pd
import joblib
import xgboost as xgb
from sklearn.metrics import (
    accuracy_score, log_loss, roc_auc_score, confusion_matrix, classification_report, ConfusionMatrixDisplay, f1_score
)
import matplotlib.pyplot as plt
import numpy as np

data = pd.read_feather("/Users/lukeromes/Desktop/Personal/Sp500Project/Data/TestData.feather")
day1_subset = data[data['Date'] == '2025-09-02']
```

Day 1 - 2025/09/02

Binary
```{python}
day1_subset = data[data['Date'] == '2025-09-02']

binaryone = joblib.load("/Users/lukeromes/Desktop/Personal/Sp500Project/Models/FinalBoostedOneDayClassifier.joblib")
drop_cols = ['Date', 'next_day_pct_change','Daily_Return',
 'next_5_day_pct_change',
 'Movement_5_day',
 'next_30_day_pct_change',
 'Movement_30_day',
 'Movement']

X = day1_subset.drop(drop_cols, axis = 1)
X_final = pd.get_dummies(X, drop_first=True)
actual = day1_subset['Movement'].astype(int)

dtest = xgb.DMatrix(X_final, label = actual)
pred = binaryone.predict(dtest)
pred_final = (pred >=.5).astype(int)

pred_final_df = pd.DataFrame(pred_final)
pred_final_df = pred_final_df.reset_index().rename(columns={'index': 'iteration', 0: 'actual up/down'})
actual = actual.reset_index().reset_index().drop('index', axis=1).rename(columns = {'level_0':'iteration'})
merged_binary = pd.merge(pred_final_df, actual, how='inner', on='iteration')
sorted_ticker_series = day1_subset['Ticker'].sort_values(ascending=True)
merged_binary['ticker'] = sorted_ticker_series.reset_index(drop=True)
merged_binary_one = merged_binary
merged_binary_one['buy'] = np.nan
merged_binary_day_one = merged_binary_one
```


Checks which stocks are going up next day
```{python}
for i in range(0, len(merged_binary_day_one )):
    if merged_binary_day_one ['Movement'].iloc[i] == 1:
        merged_binary_day_one ['buy'].iloc[i] =1
    else: 
        merged_binary_day_one ['buy'].iloc[i] =0
merged_bin_day_one_up = merged_binary_day_one[merged_binary_day_one['buy'] ==1]
```


Continuous Prediction
```{python}
day1_subset = data[data['Date'] == '2025-09-02']
drop_cols = ['Date', 'next_day_pct_change','Daily_Return',
 'next_5_day_pct_change',
 'Movement_5_day',
 'next_30_day_pct_change',
 'Movement_30_day',
 'Movement']

X = day1_subset.drop(drop_cols, axis = 1)
X_raw = pd.get_dummies(X, drop_first=True)
required_features = continuousone.feature_names
X_final = X_raw.reindex(columns=required_features, fill_value=0)
X_final = X_final.apply(pd.to_numeric, errors='coerce').fillna(0)
y_final = test['next_day_pct_change'].astype(float)
dtest = xgb.DMatrix(X_final)

y_pred_one = continuousone.predict(dtest)
y_test_new = y_final.reset_index()
y_test_new = y_test_new.reset_index().drop('index', axis =1).rename(columns = {'level_0':'iteration', 'next_day_pct_change': 'actual'})

MAE_df = pd.DataFrame(y_pred_one).reset_index().rename(columns = {'index': 'iteration', 0 : 'Initial_Predicted'})
merged = pd.merge(y_test_new, MAE_df, how = 'inner', on = 'iteration')
merged['Initial_Predicted'] = merged['Initial_Predicted'] * 100 
sorted_ticker_series = transformed_data['Ticker'].sort_values(ascending=True)
merged['ticker'] = sorted_ticker_series.reset_index(drop=True)
merged_cont_one = merged 
merged_cont_one['buy'] = np.nan
merged_cont_one['price'] = X_final['Close']
merged_cont_day_one = merged_cont_one

```

```{python}
for i in range(0, len(merged_cont_one)):
    if merged_cont_day_one ['Initial_Predicted'].iloc[i] > 0:
        merged_cont_day_one ['buy'].iloc[i] =1
    else: 
        merged_cont_day_one ['buy'].iloc[i] =0
        
merged_cont_one_up= merged_cont_day_one [merged_cont_day_one ['buy'] ==1]
```


Make sure stocks in both binary and continuous predictions so lets merge on that

```{python}

date1 = '2025-09-02'
day1merged = pd.merge(merged_bin_day_one_up, merged_cont_one_up, how = 'inner', on = 'iteration')

day1merged_final = day1merged.sort_values("Initial_Predicted", ascending=False)

day1_buys = day1merged_final.head(10)
day1_buys['Date'] = pd.to_datetime(date1) 
```

Made a df of stocks owned and buy prices and adding day 1 buys to holdings

```{python}
Holdings = pd.DataFrame()
Holdings['Stock'] = day1_buys['ticker_x'].values
Holdings['Date'] = pd.to_datetime(date1) 
prices = data[['Date','Close', 'Ticker']]
day1holdingsmerge = pd.merge(Holdings, prices, how = 'inner', left_on=['Stock','Date'], right_on=['Ticker', 'Date'])
```

adding day 1 buys to holdings

day
```{python}
day1holdingsmerge['shares_owned'] = 3333.33 / day1holdingsmerge['Close'] 
day1holdingsmerge['buy_date'] = day1_buys['Date'].values
```

```{python}
# Merge Holdings with prices to get buy price
day1holdingsmerge = pd.merge(
    Holdings,
    data[['Date', 'Ticker', 'Close']],  # make sure it's a DataFrame
    how='inner',
    left_on=['Stock', 'Date'],
    right_on=['Ticker', 'Date']
)

# Rename Close to Buy_Price
day1holdingsmerge = day1holdingsmerge.rename(columns={'Close': 'Buy_Price'})

# Calculate shares owned
day1holdingsmerge['Shares_Owned'] = 3333.33 / day1holdingsmerge['Buy_Price']

# Add buy_date
day1holdingsmerge['Buy_Date'] = day1_buys['Date'].values

day1_subset = data[data['Date'] == '2025-09-02']

current_prices = data[data['Date'] == date1]
current_prices_df = pd.merge(day1holdingsmerge, current_prices, how = 'inner', left_on=['Stock', 'Date'], right_on=['Ticker', 'Date'])
current_prices = current_prices_df['Close']

day1holdingsmerge['current_price'] = current_prices

```

Day 2 = 



