---
title: "Optimizing Stock Market Performance Using Ensemble Approaches of Machine Learning"
format: gfm
---

## Introduction

The outcome of this project is multi-fold, the goal is to predict if a stock will go up or down in the future across different time horizons and by what percent will the future stock price increase or decrease. The success of the model will be determined by not only its ability to correctly predict price movements but also its ability to act on them. This will be done by the model acting as a hedge fund manager of a financial firm trying to outperform the SP500 baseline.


## Code 

```{python}

import pandas as pd
import joblib
import pandas as pd 
import numpy as np   
from plotnine import *  
import xgboost as xgb 
from sklearn.model_selection import StratifiedShuffleSplit
from sklearn.impute import SimpleImputer
from sklearn.metrics import (
    accuracy_score, log_loss, roc_auc_score, confusion_matrix, classification_report, ConfusionMatrixDisplay, f1_score
)
from sklearn.model_selection import ParameterGrid
from tqdm import tqdm 
import matplotlib.pyplot as plt
import shap
from sklearn.metrics import roc_curve, roc_auc_score
from sklearn.preprocessing import StandardScaler
test = pd.read_feather("/Users/lukeromes/Desktop/Personal/Sp500Project/Data/TestData.feather")
transformed_data = test
binaryone = joblib.load("/Users/lukeromes/Desktop/Personal/Sp500Project/Models/FinalBoostedOneDayClassifier.joblib")
continuousone = joblib.load("/Users/lukeromes/Desktop/Personal/Sp500Project/Models/ContinuousOneDayFinal.job.lib")
```

Preparing the Data for the One-Day Binary Classifier and running the model

```{python}
import pandas as pd
import xgboost as xgb

drop_cols = ['Date', 'next_day_pct_change','Daily_Return',
 'next_5_day_pct_change',
 'Movement_5_day',
 'next_30_day_pct_change',
 'Movement_30_day',
 'Movement']

X = test.drop(drop_cols, axis = 1)
X_final = pd.get_dummies(X, drop_first=True)
actual = test['Movement'].astype(int)

dtest = xgb.DMatrix(X_final, label = actual)

pred = binaryone.predict(dtest)
pred_final = (pred >=.5).astype(int)

cm = confusion_matrix(actual, pred_final)
finalboostedcm = ConfusionMatrixDisplay(confusion_matrix=cm)
finalboostedcm.plot(cmap = "Blues")
plt.title("Final One Day Binary Confusion Matrix")
final_boosted_acc = accuracy_score(actual, pred_final)
print(final_boosted_acc)





pred_final_df = pd.DataFrame(pred_final)
pred_final_df = pred_final_df.reset_index().rename(columns={'index': 'iteration', 0: 'actual up/down'})
actual = actual.reset_index().rename(columns={'index': 'iteration'})
merged_binary = pd.merge(pred_final_df, actual, how='inner', on='iteration')
sorted_ticker_series = transformed_data['Ticker'].sort_values(ascending=True)
merged_binary['ticker'] = sorted_ticker_series.reset_index(drop=True)
merged_binary_one = merged_binary
plt.show()

```


Creating and Plotting ROC Curve
```{python}
y_true_binary = test['Movement'].astype(int) 
probabilities = pred 
auc_score = roc_auc_score(y_true_binary, probabilities)
print(f"\nArea Under the Curve (AUC) for 1-Day Movement: {auc_score:.4f}")
fpr, tpr, thresholds = roc_curve(y_true_binary, probabilities)
plt.figure(figsize=(8, 6))

plt.plot(fpr, tpr, color='navy', lw=2, label=f'ROC curve (AUC = {auc_score:.4f})')

plt.plot([0, 1], [0, 1], color='black', lw=2, linestyle='--', label='Random Classifier')

plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate (1 - Specificity)')
plt.ylabel('True Positive Rate (Sensitivity/Recall)')
plt.title('ROC Curve for 1-Day Movement Prediction')
plt.legend(loc="lower right")
plt.grid(True)
plt.show()

```

Preparing Data For Continuous Model and Running continuous model.
```{python}

X = test.drop(['Date',
    'next_day_pct_change','next_5_day_pct_change',
    'Movement_5_day','next_30_day_pct_change',
    'Movement_30_day','Movement'
], axis=1)

if 'Date' in X.columns:
    X['Date'] = pd.to_datetime(X['Date']).view('int64')


X_raw = pd.get_dummies(X, drop_first=True)

required_features = continuousone.feature_names
X_final = X_raw.reindex(columns=required_features, fill_value=0)

X_final = X_final.apply(pd.to_numeric, errors='coerce').fillna(0)
y_final = test['next_day_pct_change'].astype(float)

dtest = xgb.DMatrix(X_final)
y_pred_one = continuousone.predict(dtest)
y_test_new = y_final.reset_index()
y_test_new = y_test_new.reset_index().drop('index', axis =1).rename(columns = {'level_0':'iteration', 'next_day_pct_change': 'actual'})
MAE_df = pd.DataFrame(y_pred_one).reset_index().rename(columns = {'index': 'iteration', 0 : 'Initial_Predicted'})
merged = pd.merge(y_test_new, MAE_df, how = 'inner', on = 'iteration')


merged['Initial_Predicted'] = merged['Initial_Predicted'] * 100 


sorted_ticker_series = transformed_data['Ticker'].sort_values(ascending=True)
merged['ticker'] = sorted_ticker_series.reset_index(drop=True)
merged_cont_one = merged 
```

Continuous Model Results
```{python}
squared_errors = (merged_cont_one ['actual'] - merged_cont_one ['Initial_Predicted']) ** 2

MSE = squared_errors.mean()
MSE_percent = MSE * 100

print(f"MSE: {MSE}")
print(f"MSE_percent: {MSE_percent}")


one_day_rmse = np.sqrt(MSE) 
one_day_rmse_percent = one_day_rmse * 100

print(f" one day rmse: {one_day_rmse}")
print(f"one day rmse percent: {one_day_rmse_percent}")

threshold = 0.5 
close_accuracy = np.mean(np.abs(merged_cont_one ['actual'] - merged_cont_one ['Initial_Predicted']) <= threshold)
print(f"Within Â±0.5% accuracy (in percentage points): {close_accuracy}")
```








```{python}
#| echo: false
print("hi")
```


```{python}
#| eval: false
#| message: false
#| warning: false
import pandas as pd
```